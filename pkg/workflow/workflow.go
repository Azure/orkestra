package workflow

import (
	"context"
	"fmt"

	"github.com/Azure/Orkestra/pkg/meta"
	v1alpha13 "github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/Azure/Orkestra/api/v1alpha1"
	"github.com/go-logr/logr"
)

type ClientType string

type ExecutorFunc func(string, ExecutorAction) v1alpha13.Template

var _ = ForwardWorkflowClient{}
var _ = ReverseWorkflowClient{}
var _ = RollbackWorkflowClient{}

type Client interface {
	// Generate the object required by the workflow engine
	Generate(ctx context.Context) error

	// Submit the object required by the workflow engine generated by the Generate method
	Submit(ctx context.Context) error

	// GetType returns the workflow client type
	GetType() v1alpha1.WorkflowType

	// GetLogger returns the logger associated with the workflow client
	GetLogger() logr.Logger

	// GetNamespace returns the namespace that the workflow should run in
	GetNamespace() string

	// GetOptions returns the client options used with the workflow client
	GetOptions() ClientOptions

	// GetWorkflow returns the workflow from the k8s apiserver associated with the workflow client
	GetWorkflow(context.Context) (*v1alpha13.Workflow, error)

	// GetClient returns the k8s client associated with the workflow
	GetClient() client.Client

	// GetAppGroup returns the app group from the workflow client
	GetAppGroup() *v1alpha1.ApplicationGroup
}

type ClientOptions struct {
	parallelism *int64
	stagingRepo string
	namespace   string
}

type Builder struct {
	client     client.Client
	clientType v1alpha1.WorkflowType
	options    ClientOptions
	executor   ExecutorFunc
	logger     logr.Logger

	forwardWorkflow *v1alpha13.Workflow
	appGroup        *v1alpha1.ApplicationGroup
}

type ForwardWorkflowClient struct {
	client.Client
	logr.Logger
	ClientOptions
	executor ExecutorFunc

	workflow *v1alpha13.Workflow
	appGroup *v1alpha1.ApplicationGroup
}

type RollbackWorkflowClient struct {
	client.Client
	logr.Logger
	ClientOptions
	executor ExecutorFunc

	workflow *v1alpha13.Workflow
	appGroup *v1alpha1.ApplicationGroup
}

type ReverseWorkflowClient struct {
	client.Client
	logr.Logger
	ClientOptions
	executor ExecutorFunc

	forwardWorkflow *v1alpha13.Workflow
	reverseWorkflow *v1alpha13.Workflow
	appGroup        *v1alpha1.ApplicationGroup
}

func NewBuilder(client client.Client, logger logr.Logger) *Builder {
	return &Builder{
		client:  client,
		options: ClientOptions{},
		logger:  logger,
	}
}

func NewBuilderFromClient(client Client) *Builder {
	return &Builder{
		client:   client.GetClient(),
		options:  client.GetOptions(),
		appGroup: client.GetAppGroup(),
		logger:   client.GetLogger(),
	}
}

func (builder *Builder) Forward(appGroup *v1alpha1.ApplicationGroup) *Builder {
	builder.clientType = v1alpha1.Forward
	builder.appGroup = appGroup
	return builder
}

func (builder *Builder) Reverse(appGroup *v1alpha1.ApplicationGroup) *Builder {
	builder.clientType = v1alpha1.Reverse
	builder.appGroup = appGroup
	return builder
}

func (builder *Builder) Rollback(appGroup *v1alpha1.ApplicationGroup) *Builder {
	builder.clientType = v1alpha1.Rollback
	builder.appGroup = appGroup
	return builder
}

func (builder *Builder) WithParallelism(numNodes int64) *Builder {
	builder.options.parallelism = &numNodes
	return builder
}

func (builder *Builder) WithStagingRepo(stagingURL string) *Builder {
	builder.options.stagingRepo = stagingURL
	return builder
}

func (builder *Builder) InNamespace(namespace string) *Builder {
	builder.options.namespace = namespace
	return builder
}

func (builder *Builder) WithExecutor(executor ExecutorFunc) *Builder {
	builder.executor = executor
	return builder
}

func (builder *Builder) Build() Client {
	switch builder.clientType {
	case v1alpha1.Forward:
		forwardClient := &ForwardWorkflowClient{
			Client:        builder.client,
			Logger:        builder.logger,
			ClientOptions: builder.options,
			appGroup:      builder.appGroup,
			executor:      builder.executor,
		}
		if builder.executor == nil {
			forwardClient.executor = chainedDefaultKeptnExecutor
		}
		return forwardClient
	case v1alpha1.Reverse:
		reverseClient := &ReverseWorkflowClient{
			Client:        builder.client,
			Logger:        builder.logger,
			ClientOptions: builder.options,
			appGroup:      builder.appGroup,
			executor:      builder.executor,
		}
		if builder.executor == nil {
			reverseClient.executor = chainedDefaultKeptnExecutor
		}
		return reverseClient
	default:
		rollbackClient := &RollbackWorkflowClient{
			Client:        builder.client,
			Logger:        builder.logger,
			ClientOptions: builder.options,
			appGroup:      builder.appGroup,
			executor:      builder.executor,
		}
		if builder.executor == nil {
			rollbackClient.executor = chainedDefaultKeptnExecutor
		}
		return rollbackClient
	}
}

// Run calls the generate and Submit commands of the workflow client
func Run(ctx context.Context, wfClient Client) error {
	if err := wfClient.Generate(ctx); err != nil {
		return fmt.Errorf("failed to generate workflow: %w", err)
	}
	if err := wfClient.Submit(ctx); err != nil {
		return fmt.Errorf("failed to submit workflow: %w", err)
	}
	return nil
}

// Suspend sets the suspend flag on the workflow associated with the workflow client
// if the workflow still exists on the cluster
func Suspend(ctx context.Context, wfClient Client) error {
	// suspend a workflow if it is not already finished or suspended
	workflow, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return fmt.Errorf("failed to suspend the workflow: %w", err)
	} else if err != nil || !workflow.Status.FinishedAt.IsZero() {
		wfClient.GetLogger().Info("workflow not found, no need to suspend")
		return nil
	}
	if workflow.Spec.Suspend == nil || !*workflow.Spec.Suspend {
		wfClient.GetLogger().Info("suspending the workflow")
		patch := client.MergeFrom(workflow.DeepCopy())

		suspend := true
		workflow.Spec.Suspend = &suspend
		if err := wfClient.GetClient().Patch(ctx, workflow, patch); err != nil {
			return fmt.Errorf("failed to patch the workflow: %w", err)
		}
		SetSuspended(wfClient)
	}
	return nil
}

// DeleteWorkflow removes the workflow from the api server associated with
// the workflow client
func DeleteWorkflow(ctx context.Context, wfClient Client) error {
	workflow, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return err
	}
	return wfClient.GetClient().Delete(ctx, workflow)
}

// UpdateStatus updates the status of the owning appGroup with the workflow condition type
// of the workflow client
func UpdateStatus(ctx context.Context, wfClient Client) error {
	wf, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return err
	} else if err != nil {
		// We just return and don't update if we don't find the workflow
		return nil
	}
	switch toConditionReason(wf.Status.Phase) {
	case meta.FailedReason:
		wfClient.GetLogger().Info("workflow node is in failed state")
		SetFailed(wfClient, "workflow node is in failed state")
	case meta.SucceededReason:
		wfClient.GetLogger().Info("workflow has succeeded")
		SetSucceeded(wfClient)
	default:
		wfClient.GetLogger().Info("workflow is still progressing")
		SetProgressing(wfClient)
	}
	return nil
}

// SetProgressing sets one of the workflow conditions in the progressing state
func SetProgressing(wfClient Client) {
	if condition, ok := v1alpha1.WorkflowConditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionUnknown, meta.ProgressingReason, "workflow is progressing...")
	}
}

// SetSucceeded sets one of the workflow conditions in the succeeded state
func SetSucceeded(wfClient Client) {
	if condition, ok := v1alpha1.WorkflowConditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionTrue, meta.SucceededReason, "workflow succeeded")
	}
}

// SetFailed sets one of the workflow conditions in the failed state
func SetFailed(wfClient Client, message string) {
	if condition, ok := v1alpha1.WorkflowConditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionFalse, meta.FailedReason, message)
	}
}

// SetSuspended sets one of the workflow conditions in the suspended state
func SetSuspended(wfClient Client) {
	if condition, ok := v1alpha1.WorkflowConditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionFalse, meta.SuspendedReason, "workflow is suspended")
	}
}

// IsFailed checks if the workflow created by the workflow client is in a failed state
func IsFailed(ctx context.Context, wfClient Client) (bool, error) {
	wf, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return false, fmt.Errorf("failed to get workflow: %w", err)
	}
	if toConditionReason(wf.Status.Phase) == meta.FailedReason {
		return true, nil
	}
	return false, nil
}

// IsSucceeded checks if the workflow created by the workflow client is in a succeeded state
func IsSucceeded(ctx context.Context, wfClient Client) (bool, error) {
	wf, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return false, fmt.Errorf("failed to get workflow: %w", err)
	}
	if toConditionReason(wf.Status.Phase) == meta.SucceededReason {
		return true, nil
	}
	return false, nil
}

func toConditionReason(nodePhase v1alpha13.WorkflowPhase) string {
	switch nodePhase {
	case v1alpha13.WorkflowFailed:
		return meta.FailedReason
	case v1alpha13.WorkflowSucceeded:
		return meta.SucceededReason
	default:
		return meta.ProgressingReason
	}
}

func initWorkflowObject(name, namespace string, parallelism *int64) *v1alpha13.Workflow {
	return &v1alpha13.Workflow{
		ObjectMeta: v1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
			Labels:    map[string]string{HeritageLabel: Project},
		},
		TypeMeta: v1.TypeMeta{
			APIVersion: v1alpha13.WorkflowSchemaGroupVersionKind.GroupVersion().String(),
			Kind:       v1alpha13.WorkflowSchemaGroupVersionKind.Kind,
		},
		Spec: v1alpha13.WorkflowSpec{
			Entrypoint:  EntrypointTemplateName,
			Templates:   make([]v1alpha13.Template, 0),
			Parallelism: parallelism,
			PodGC: &v1alpha13.PodGC{
				Strategy: v1alpha13.PodGCOnWorkflowCompletion,
			},
		},
	}
}

func updateWorkflowTemplates(wf *v1alpha13.Workflow, tpls ...v1alpha13.Template) {
	wf.Spec.Templates = append(wf.Spec.Templates, tpls...)
}
