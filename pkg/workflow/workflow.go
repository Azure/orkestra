package workflow

import (
	"context"
	"fmt"

	"github.com/Azure/Orkestra/pkg/meta"
	v1alpha12 "github.com/argoproj/argo/pkg/apis/workflow/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/Azure/Orkestra/api/v1alpha1"
	"github.com/go-logr/logr"
)

type ClientType string

type ExecutorFunc func(string, ExecutorAction) v1alpha12.Template

const (
	Forward  ClientType = "forward"
	Reverse  ClientType = "reverse"
	Rollback ClientType = "rollback"
)

var conditionMap = map[ClientType]string{
	Forward:  meta.ForwardWorkflowSucceededCondition,
	Reverse:  meta.ReverseWorkflowSucceededCondition,
	Rollback: meta.RollbackWorkflowSucceededCondition,
}

var _ = ForwardWorkflowClient{}
var _ = ReverseWorkflowClient{}
var _ = RollbackWorkflowClient{}

type Client interface {
	// Generate the object required by the workflow engine
	Generate(ctx context.Context) error

	// Submit the object required by the workflow engine generated by the Generate method
	Submit(ctx context.Context) error

	// GetType returns the workflow client type
	GetType() ClientType

	GetNamespace() string

	GetOptions() ClientOptions

	// GetLogger returns the logger associated with the workflow client
	GetLogger() logr.Logger

	// GetWorkflow returns the workflow from the k8s apiserver associated with the workflow client
	GetWorkflow(context.Context) (*v1alpha12.Workflow, error)

	// GetClient returns the k8s client associated with the workflow
	GetClient() client.Client

	// GetAppGroup returns the app group from the workflow client
	GetAppGroup() *v1alpha1.ApplicationGroup
}

type ClientOptions struct {
	parallelism *int64
	stagingRepo string
	namespace   string
}

type Builder struct {
	client     client.Client
	logger     logr.Logger
	clientType ClientType
	options    ClientOptions
	executor   ExecutorFunc

	forwardWorkflow *v1alpha12.Workflow
	appGroup        *v1alpha1.ApplicationGroup
}

type ForwardWorkflowClient struct {
	client.Client
	logr.Logger
	ClientOptions
	executor ExecutorFunc

	workflow *v1alpha12.Workflow
	appGroup *v1alpha1.ApplicationGroup
}

type RollbackWorkflowClient struct {
	client.Client
	logr.Logger
	ClientOptions
	executor ExecutorFunc

	workflow *v1alpha12.Workflow
	appGroup *v1alpha1.ApplicationGroup
}

type ReverseWorkflowClient struct {
	client.Client
	logr.Logger
	ClientOptions
	executor ExecutorFunc

	nodes           map[string]v1alpha12.NodeStatus
	forwardWorkflow *v1alpha12.Workflow
	reverseWorkflow *v1alpha12.Workflow
	appGroup        *v1alpha1.ApplicationGroup

	forwardClient *ForwardWorkflowClient
}

func NewBuilder(client client.Client, logger logr.Logger) *Builder {
	return &Builder{
		client:  client,
		logger:  logger,
		options: ClientOptions{},
	}
}

func (builder *Builder) Forward(appGroup *v1alpha1.ApplicationGroup) *Builder {
	builder.clientType = Forward
	builder.appGroup = appGroup
	return builder
}

func (builder *Builder) Reverse(appGroup *v1alpha1.ApplicationGroup) *Builder {
	builder.clientType = Reverse
	builder.appGroup = appGroup
	return builder
}

func (builder *Builder) Rollback(appGroup *v1alpha1.ApplicationGroup) *Builder {
	builder.clientType = Rollback
	builder.appGroup = appGroup
	return builder
}

func (builder *Builder) WithParallelism(numNodes int64) *Builder {
	builder.options.parallelism = &numNodes
	return builder
}

func (builder *Builder) WithStagingRepo(stagingURL string) *Builder {
	builder.options.stagingRepo = stagingURL
	return builder
}

func (builder *Builder) InNamespace(namespace string) *Builder {
	builder.options.namespace = namespace
	return builder
}

func (builder *Builder) WithExecutor(executor ExecutorFunc) *Builder {
	builder.executor = executor
	return builder
}

func (builder *Builder) Build() (Client, error) {
	forwardClient := &ForwardWorkflowClient{
		Client:        builder.client,
		Logger:        builder.logger,
		ClientOptions: builder.options,
		appGroup:      builder.appGroup,
		executor:      builder.executor,
	}
	if builder.executor == nil {
		forwardClient.executor = defaultExecutor
	}

	switch builder.clientType {
	case Forward:
		return forwardClient, nil
	case Reverse:
		reverseClient := &ReverseWorkflowClient{
			Client:        builder.client,
			Logger:        builder.logger,
			ClientOptions: builder.options,
			appGroup:      builder.appGroup,
			executor:      builder.executor,
			forwardClient: forwardClient,
		}
		if builder.executor == nil {
			reverseClient.executor = defaultExecutor
		}
		return reverseClient, nil
	case Rollback:
		rollbackClient := &RollbackWorkflowClient{
			Client:        builder.client,
			Logger:        builder.logger,
			ClientOptions: builder.options,
			appGroup:      builder.appGroup,
			executor:      builder.executor,
		}
		return rollbackClient, nil
	}
	return nil, fmt.Errorf("failed to build engine because type wasn't specified")
}

func Run(ctx context.Context, wfClient Client) error {
	if err := wfClient.Generate(ctx); err != nil {
		wfClient.GetLogger().Error(err, "engine failed to generate workflow")
		return fmt.Errorf("failed to generate workflow : %w", err)
	}
	if err := wfClient.Submit(ctx); err != nil {
		wfClient.GetLogger().Error(err, "engine failed to submit reverse workflow")
		return err
	}
	return nil
}

func Suspend(ctx context.Context, wfClient Client) error {
	// suspend a workflow if it is not already finished or suspended
	workflow, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return err
	} else if err != nil || !workflow.Status.FinishedAt.IsZero() {
		wfClient.GetLogger().Info("workflow not found, no need to suspend")
		return nil
	}
	if workflow.Spec.Suspend == nil || !*workflow.Spec.Suspend {
		wfClient.GetLogger().Info("suspending the workflow")
		patch := client.MergeFrom(workflow.DeepCopy())

		suspend := true
		workflow.Spec.Suspend = &suspend
		if err := wfClient.GetClient().Patch(ctx, workflow, patch); err != nil {
			wfClient.GetLogger().Error(err, "failed to patch workflow")
			return err
		}
		SetSuspended(wfClient)
	}
	return nil
}

func DeleteWorkflow(ctx context.Context, wfClient Client) error {
	workflow, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return err
	}
	return wfClient.GetClient().Delete(ctx, workflow)
}

func UpdateStatus(ctx context.Context, wfClient Client) error {
	wf, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return err
	} else if err != nil {
		// We just return and don't update if we don't find the workflow
		return nil
	}
	switch toConditionReason(wf.Status.Phase) {
	case meta.FailedReason:
		wfClient.GetLogger().Info("workflow node is in failed state")
		SetFailed(wfClient, "workflow node is in failed state")
	case meta.SucceededReason:
		wfClient.GetLogger().V(1).Info("workflow has succeeded")
		SetSucceeded(wfClient)
	default:
		wfClient.GetLogger().V(1).Info("workflow is still progressing")
		SetProgressing(wfClient)
	}
	return nil
}

func toConditionReason(nodePhase v1alpha12.NodePhase) string {
	switch nodePhase {
	case v1alpha12.NodeError, v1alpha12.NodeFailed:
		return meta.FailedReason
	case v1alpha12.NodeSucceeded:
		return meta.SucceededReason
	default:
		return meta.ProgressingReason
	}
}

// SetProgressing sets one of the workflow conditions in the progressing state
func SetProgressing(wfClient Client) {
	if condition, ok := conditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionUnknown, meta.ProgressingReason, "workflow is progressing...")
	}
}

// SetSucceeded sets one of the workflow conditions in the succeeded state
func SetSucceeded(wfClient Client) {
	if condition, ok := conditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionTrue, meta.SucceededReason, "workflow succeeded")
	}
}

// SetFailed sets one of the workflow conditions in the failed state
func SetFailed(wfClient Client, message string) {
	if condition, ok := conditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionFalse, meta.FailedReason, message)
	}
}

// SetSuspended sets one of the workflow conditions in the suspended state
func SetSuspended(wfClient Client) {
	if condition, ok := conditionMap[wfClient.GetType()]; ok {
		meta.SetResourceCondition(wfClient.GetAppGroup(), condition, metav1.ConditionFalse, meta.SuspendedReason, "workflow is suspended")
	}
}

func IsFailed(ctx context.Context, wfClient Client) (bool, error) {
	wf, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return false, err
	}
	if toConditionReason(wf.Status.Phase) == meta.FailedReason {
		return true, nil
	}
	return false, nil
}

func IsSucceeded(ctx context.Context, wfClient Client) (bool, error) {
	wf, err := wfClient.GetWorkflow(ctx)
	if client.IgnoreNotFound(err) != nil {
		return false, err
	}
	if toConditionReason(wf.Status.Phase) == meta.SucceededReason {
		return true, nil
	}
	return false, nil
}

func getNodes(wf *v1alpha12.Workflow) map[string]v1alpha12.NodeStatus {
	nodes := make(map[string]v1alpha12.NodeStatus)
	for _, node := range wf.Status.Nodes {
		nodes[node.ID] = node
	}
	return nodes
}

func initWorkflowObject(name, namespace string, parallelism *int64) *v1alpha12.Workflow {
	return &v1alpha12.Workflow{
		ObjectMeta: v1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
			Labels:    map[string]string{HeritageLabel: Project},
		},
		TypeMeta: v1.TypeMeta{
			APIVersion: v1alpha12.WorkflowSchemaGroupVersionKind.GroupVersion().String(),
			Kind:       v1alpha12.WorkflowSchemaGroupVersionKind.Kind,
		},
		Spec: v1alpha12.WorkflowSpec{
			Entrypoint:  EntrypointTemplateName,
			Templates:   make([]v1alpha12.Template, 0),
			Parallelism: parallelism,
			PodGC: &v1alpha12.PodGC{
				Strategy: v1alpha12.PodGCOnWorkflowCompletion,
			},
		},
	}
}

func updateWorkflowTemplates(wf *v1alpha12.Workflow, tpls ...v1alpha12.Template) {
	wf.Spec.Templates = append(wf.Spec.Templates, tpls...)
}
